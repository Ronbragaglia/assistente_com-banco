# -*- coding: utf-8 -*-
"""Assistente_com banco

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lKNbItdaNY9xBIWFRBAvhWgP8OidGgRC
"""

import sqlite3
from openai import OpenAI
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
import numpy as np


client = OpenAI(api_key='')


conexao = sqlite3.connect('eventos.db')
cursor = conexao.cursor()


cursor.execute('''
CREATE TABLE IF NOT EXISTS eventos (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    nome TEXT NOT NULL,
    data TEXT NOT NULL,
    local TEXT NOT NULL,
    descricao TEXT NOT NULL
)
''')


cursor.execute('''
CREATE TABLE IF NOT EXISTS perguntas_respostas (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    pergunta TEXT NOT NULL,
    resposta TEXT NOT NULL
)
''')


cursor.execute("SELECT COUNT(*) FROM eventos")
if cursor.fetchone()[0] == 0:
    cursor.execute("INSERT INTO eventos (nome, data, local, descricao) VALUES ('Festival de Música', '2023-12-15', 'Parque Central', 'Um festival com bandas internacionais.')")
    cursor.execute("INSERT INTO eventos (nome, data, local, descricao) VALUES ('Feira de Tecnologia', '2024-02-20', 'Centro de Eventos', 'Apresentação das últimas inovações tecnológicas.')")
    conexao.commit()


def buscar_informacoes_do_banco():
    """
    Busca informações do banco de dados sobre eventos.

    Returns:
        str: Contexto formatado com informações dos eventos.
    """
    cursor.execute("SELECT nome, data, local, descricao FROM eventos")
    resultados = cursor.fetchall()
    contexto = "Informações sobre eventos:\n\n"
    for evento in resultados:
        nome, data, local, descricao = evento
        contexto += f"- Nome: {nome}\n  Data: {data}\n  Local: {local}\n  Descrição: {descricao}\n\n"
    return contexto


def buscar_resposta_similar(pergunta, limite_similaridade=0.7):
    """
    Busca uma resposta semelhante no banco de dados de perguntas e respostas.

    Args:
        pergunta (str): A pergunta do usuário.
        limite_similaridade (float): Limite de similaridade para considerar uma resposta válida.

    Returns:
        str: Resposta semelhante, se encontrada, ou None.
    """
    cursor.execute("SELECT pergunta, resposta FROM perguntas_respostas")
    perguntas_respostas = cursor.fetchall()

    if not perguntas_respostas:
        return None

    perguntas = [pq[0] for pq in perguntas_respostas]
    respostas = [pq[1] for pq in perguntas_respostas]


    vectorizer = TfidfVectorizer()
    matriz_tfidf = vectorizer.fit_transform([pergunta] + perguntas)
    similaridades = cosine_similarity(matriz_tfidf[0:1], matriz_tfidf[1:]).flatten()


    indice_similar = np.argmax(similaridades)
    if similaridades[indice_similar] > limite_similaridade:
        return respostas[indice_similar]
    return None


def adicionar_pergunta_resposta(pergunta, resposta):
    """
    Adiciona uma nova pergunta e resposta ao banco de dados.

    Args:
        pergunta (str): A pergunta do usuário.
        resposta (str): A resposta gerada pela IA.
    """
    cursor.execute("INSERT INTO perguntas_respostas (pergunta, resposta) VALUES (?, ?)", (pergunta, resposta))
    conexao.commit()


def gerar_resposta(contexto, pergunta):
    """
    Gera uma resposta para uma pergunta com base em um contexto fornecido.

    Args:
        contexto (str): O contexto ou informação de fundo.
        pergunta (str): A pergunta a ser respondida.

    Returns:
        str: A resposta gerada pela IA.
    """

    prompt = f"{contexto}\n\nPergunta: {pergunta}\nResposta:"


    resposta = client.chat.completions.create(
        model="gpt-3.5-turbo",
        messages=[
            {"role": "system", "content": "Você é um assistente útil especializado em eventos."},
            {"role": "user", "content": prompt}
        ]
    )


    return resposta.choices[0].message.content


def main():
    """
    Função principal que gerencia a interação com o usuário.
    """
    print("Bem-vindo ao Assistente de IA para Eventos! Digite 'sair' a qualquer momento para encerrar.")


    contexto = buscar_informacoes_do_banco()
    print("\nContexto atualizado com informações do banco de dados:\n")
    print(contexto)

    while True:

        pergunta = input("\nVocê: ")


        if pergunta.lower() == "sair":
            print("Encerrando o programa. Até mais!")
            break

        resposta_similar = buscar_resposta_similar(pergunta)
        if resposta_similar:
            print(f"\nAssistente: {resposta_similar} (Resposta recuperada do banco de dados)")
        else:

            resposta = gerar_resposta(contexto, pergunta)
            print(f"\nAssistente: {resposta}")


            adicionar_pergunta_resposta(pergunta, resposta)


if __name__ == "__main__":
    main()